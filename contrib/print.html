<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cargo Contributor Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="issues.html"><strong aria-hidden="true">2.</strong> Issue Tracker</a></li><li class="chapter-item expanded "><a href="process/index.html"><strong aria-hidden="true">3.</strong> Process</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="process/working-on-cargo.html"><strong aria-hidden="true">3.1.</strong> Working on Cargo</a></li><li class="chapter-item expanded "><a href="process/release.html"><strong aria-hidden="true">3.2.</strong> Release process</a></li><li class="chapter-item expanded "><a href="process/unstable.html"><strong aria-hidden="true">3.3.</strong> Unstable features</a></li></ol></li><li class="chapter-item expanded "><a href="design.html"><strong aria-hidden="true">4.</strong> Design Principles</a></li><li class="chapter-item expanded "><a href="architecture/index.html"><strong aria-hidden="true">5.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/codebase.html"><strong aria-hidden="true">5.1.</strong> Codebase Overview</a></li><li class="chapter-item expanded "><a href="architecture/subcommands.html"><strong aria-hidden="true">5.2.</strong> SubCommands</a></li><li class="chapter-item expanded "><a href="architecture/console.html"><strong aria-hidden="true">5.3.</strong> Console Output</a></li><li class="chapter-item expanded "><a href="architecture/packages.html"><strong aria-hidden="true">5.4.</strong> Packages and Resolution</a></li><li class="chapter-item expanded "><a href="architecture/compilation.html"><strong aria-hidden="true">5.5.</strong> Compilation</a></li><li class="chapter-item expanded "><a href="architecture/files.html"><strong aria-hidden="true">5.6.</strong> Files</a></li></ol></li><li class="chapter-item expanded "><a href="tests/index.html"><strong aria-hidden="true">6.</strong> Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tests/running.html"><strong aria-hidden="true">6.1.</strong> Running Tests</a></li><li class="chapter-item expanded "><a href="tests/writing.html"><strong aria-hidden="true">6.2.</strong> Writing Tests</a></li><li class="chapter-item expanded "><a href="tests/profiling.html"><strong aria-hidden="true">6.3.</strong> Benchmarking and Profiling</a></li><li class="chapter-item expanded "><a href="tests/crater.html"><strong aria-hidden="true">6.4.</strong> Crater</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cargo Contributor Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/tree/master/src/doc/contrib/src" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Thank you for your interest in contributing to <a href="https://doc.rust-lang.org/cargo/">Cargo</a>! This guide provides an
overview of how to contribute to Cargo, how to dive into the code, and how the
testing infrastructure works.</p>
<p>There are many ways to contribute, such as <a href="https://users.rust-lang.org/">helping other users</a>, <a href="issues.html">filing
issues</a>, <a href="https://github.com/rust-lang/cargo/tree/master/src/doc">improving the documentation</a>, <a href="process/index.html#working-on-small-bugs">fixing bugs</a>, and working on <a href="process/index.html#working-on-small-features">small</a>
and <a href="process/index.html#working-on-large-features">large features</a>.</p>
<p>If you have a general question about Cargo or its internals, feel free to ask
on <a href="https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo">Zulip</a>.</p>
<p>This guide assumes you have some familiarity with Rust, and how to use Cargo,
<a href="https://rust-lang.github.io/rustup/">rustup</a>, and general development tools like <a href="https://git-scm.com/">git</a>.</p>
<p>Please also read the <a href="https://www.rust-lang.org/policies/code-of-conduct">Rust Code of Conduct</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="issue-tracker"><a class="header" href="#issue-tracker">Issue Tracker</a></h1>
<p>Cargo’s issue tracker is located at
<a href="https://github.com/rust-lang/cargo/issues/">https://github.com/rust-lang/cargo/issues/</a>. This is the primary spot where
we track bugs and small feature requests. See <a href="process/index.html">Process</a> for more about our
process for proposing changes.</p>
<h2 id="filing-issues"><a class="header" href="#filing-issues">Filing issues</a></h2>
<p>We can’t fix what we don’t know about, so please report problems liberally.
This includes problems with understanding the documentation, unhelpful error
messages, and unexpected behavior.</p>
<p><strong>If you think that you have identified an issue with Cargo that might
compromise its users’ security, please do not open a public issue on GitHub.
Instead, we ask you to refer to Rust’s <a href="https://www.rust-lang.org/security.html">security policy</a>.</strong></p>
<p>Opening an issue is as easy as following <a href="https://github.com/rust-lang/cargo/issues/new/choose">this link</a>. There are
several templates for different issue kinds, but if none of them fit your
issue, don’t hesitate to modify one of the templates, or click the <a href="https://github.com/rust-lang/cargo/issues/new">Open a
blank issue</a> link.</p>
<p>The Rust tools are spread across multiple repositories in the Rust
organization. It may not always be clear where to file an issue. No worries!
If you file in the wrong tracker, someone will either transfer it to the
correct one or ask you to move it. Some other repositories that may be
relevant are:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust"><code>rust-lang/rust</code></a> — Home for the <a href="https://doc.rust-lang.org/rustc/"><code>rustc</code></a> compiler and <a href="https://doc.rust-lang.org/rustdoc/"><code>rustdoc</code></a>.</li>
<li><a href="https://github.com/rust-lang/rustup"><code>rust-lang/rustup</code></a> — Home for the <a href="https://rust-lang.github.io/rustup/"><code>rustup</code></a> toolchain installer.</li>
<li><a href="https://github.com/rust-lang/rustfmt"><code>rust-lang/rustfmt</code></a> — Home for the <code>rustfmt</code> tool, which also includes <code>cargo fmt</code>.</li>
<li><a href="https://github.com/rust-lang/rust-clippy"><code>rust-lang/rust-clippy</code></a> — Home for the <code>clippy</code> tool, which also includes <code>cargo clippy</code>.</li>
<li><a href="https://github.com/rust-lang/crates.io"><code>rust-lang/crates.io</code></a> — Home for the <a href="https://crates.io/">crates.io</a> website.</li>
</ul>
<p>Issues with <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> can be tricky to know where they should be filed,
since the fixes are driven by <code>rustc</code>, processed by <a href="https://github.com/rust-lang/rustfix/"><code>rustfix</code></a>, and the
front-interface is implemented in Cargo. Feel free to file in the Cargo issue
tracker, and it will get moved to one of the other issue trackers if
necessary.</p>
<h2 id="issue-labels"><a class="header" href="#issue-labels">Issue labels</a></h2>
<p><a href="https://github.com/rust-lang/cargo/labels">Issue labels</a> are very helpful to identify the types of issues and which
category they are related to. The Cargo team typically manages assigning
labels. The labels use a naming convention with short prefixes and colors to
indicate the kind of label:</p>
<ul>
<li>
<p>Yellow, <strong>A</strong>-prefixed labels state which <strong>area</strong> of the project an issue
relates to.</p>
</li>
<li>
<p>Light purple, <strong>C</strong>-prefixed labels represent the <strong>category</strong> of an issue.
In particular, <strong><a href="https://github.com/rust-lang/cargo/labels/C-feature-request">C-feature-request</a></strong> marks <em>proposals</em> for new features. If
an issue is <strong>C-feature-request</strong>, but is not <strong><a href="https://github.com/rust-lang/cargo/labels/Feature%20accepted">Feature accepted</a></strong> or
<strong><a href="https://github.com/rust-lang/cargo/labels/I-nominated">I-nominated</a></strong>, then it was not thoroughly discussed, and might need some
additional design or perhaps should be implemented as an external subcommand
first. Ping @rust-lang/cargo if you want to send a PR for such issue.</p>
</li>
<li>
<p>Dark purple, <strong>Command</strong>-prefixed labels mean the issue has to do with a
specific cargo command.</p>
</li>
<li>
<p>Green, <strong>E</strong>-prefixed labels indicate the level of <strong>experience</strong> or
<strong>effort</strong> necessary to fix the issue. <strong><a href="https://github.com/rust-lang/cargo/labels/E-mentor">E-mentor</a></strong> issues also
have some instructions on how to get started. Generally, all of the
<strong>E</strong>-prefixed labels are issues that are ready for someone to contribute
to!</p>
</li>
<li>
<p>Red, <strong>I</strong>-prefixed labels indicate the <strong>importance</strong> of the issue. The
<strong><a href="https://github.com/rust-lang/cargo/labels/I-nominated">I-nominated</a></strong> label indicates that an issue has been nominated for
prioritizing at the next triage meeting.</p>
</li>
<li>
<p>Purple gray, <strong>O</strong>-prefixed labels are the <strong>operating system</strong> or platform
that this issue is specific to.</p>
</li>
<li>
<p>Orange, <strong>P</strong>-prefixed labels indicate a bug’s <strong>priority</strong>.</p>
</li>
<li>
<p><strong>S</strong>-prefixed labels are “status” labels, typically used for PRs, but can
also indicate an issue is <strong><a href="https://github.com/rust-lang/cargo/labels/S-blocked">S-blocked</a></strong>.</p>
</li>
<li>
<p>The light orange <strong><a href="https://github.com/rust-lang/cargo/issues?q=label%3Arelnotes">relnotes</a></strong> label marks issues that should be highlighted
in the <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md">Rust release notes</a> of the next release.</p>
</li>
<li>
<p>Dark blue, <strong>Z</strong>-prefixed labels are for unstable, <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html">nightly features</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="process"><a class="header" href="#process">Process</a></h1>
<p>This chapter gives an overview of how Cargo comes together, and how you can be
a part of that process.</p>
<p>See the <a href="process/working-on-cargo.html">Working on Cargo</a> chapter for an overview of the contribution
process.</p>
<p>Please read the guidelines below before working on an issue or new feature.</p>
<p><strong>Due to limited review capacity, the Cargo team is not accepting new features
or major changes at this time. Please consult with the team before opening a
new PR. Only issues that have been explicitly marked as accepted will be
reviewed.</strong></p>
<h2 id="cargo-team"><a class="header" href="#cargo-team">Cargo team</a></h2>
<p>Cargo is managed by a <a href="https://www.rust-lang.org/governance/teams/dev-tools#cargo">team</a> of volunteers. The Cargo Team reviews all
changes, and sets the direction for the project.</p>
<p>The team meets on a weekly basis on a video chat. If you are interested in
participating, feel free to contact us on <a href="https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo">Zulip</a>.</p>
<h2 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h2>
<p>The <a href="https://github.com/rust-lang/cargo/projects/1">Roadmap Project Board</a> is used for tracking major initiatives. This gives
an overview of the things the team is interested in and thinking about.</p>
<p>The <a href="https://github.com/rust-lang/cargo/projects/2">RFC Project Board</a> is used for tracking <a href="https://github.com/rust-lang/rfcs/">RFCs</a>.</p>
<h2 id="working-on-small-bugs"><a class="header" href="#working-on-small-bugs">Working on small bugs</a></h2>
<p>Issues labeled with the <a href="https://github.com/rust-lang/cargo/labels/E-help-wanted">E-help-wanted</a>, <a href="https://github.com/rust-lang/cargo/labels/E-easy">E-easy</a>, or <a href="https://github.com/rust-lang/cargo/labels/E-mentor">E-mentor</a> <a href="process/../issues.html#issue-labels">labels</a> are
typically issues that the Cargo team wants to see addressed, and are
relatively easy to get started with. If you are interested in one of those,
and it has not already been assigned to someone, leave a comment. See <a href="process/index.html#issue-assignment">Issue
assignment</a> below for assigning yourself.</p>
<p>If there is a specific issue that you are interested in, but it doesn’t have
one of the <code>E-</code> labels, leave a comment on the issue. If a Cargo team member
has the time to help out, they will respond to help with the next steps.</p>
<h2 id="working-on-large-bugs"><a class="header" href="#working-on-large-bugs">Working on large bugs</a></h2>
<p>Some issues may be difficult to fix. They may require significant code
changes, or major design decisions. The <a href="https://github.com/rust-lang/cargo/labels/E-medium">E-medium</a> and <a href="https://github.com/rust-lang/cargo/labels/E-hard">E-hard</a> <a href="process/../issues.html#issue-labels">labels</a> can
be used to tag such issues. These will typically involve some discussion with
the Cargo team on how to tackle it.</p>
<h2 id="working-on-small-features"><a class="header" href="#working-on-small-features">Working on small features</a></h2>
<p>Small feature requests are typically managed on the <a href="https://github.com/rust-lang/cargo/labels/C-feature-request">issue
tracker</a>. Features that the Cargo team have approved
will have the <a href="https://github.com/rust-lang/cargo/labels/Feature%20accepted">Feature accepted</a> label or the <a href="https://github.com/rust-lang/cargo/labels/E-mentor">E-mentor</a> label. If there is a
feature request that you are interested in, feel free to leave a comment
expressing your interest. If a Cargo team member has the time to help out,
they will respond to help with the next steps. Keep in mind that the Cargo
team has limited time, and may not be able to help with every feature request.
Most of them require some design work, which can be difficult. Check out the
<a href="process/../design.html">design principles chapter</a> for some guidance.</p>
<h2 id="working-on-large-features"><a class="header" href="#working-on-large-features">Working on large features</a></h2>
<p>Cargo follows the Rust model of evolution. Major features usually go through
an <a href="https://github.com/rust-lang/rfcs/">RFC process</a>. Therefore, before opening a feature request issue create a
Pre-RFC thread on the <a href="https://internals.rust-lang.org/">internals</a> forum to get preliminary feedback.</p>
<p>Implementing a feature as a <a href="https://doc.rust-lang.org/cargo/reference/external-tools.html#custom-subcommands">custom subcommand</a> is encouraged as
it helps demonstrate the demand for the functionality and is a great way to
deliver a working solution faster as it can iterate outside of Cargo’s release
cadence.</p>
<p>See the <a href="process/unstable.html">unstable chapter</a> for how new major features are typically
implemented.</p>
<h2 id="bots-and-infrastructure"><a class="header" href="#bots-and-infrastructure">Bots and infrastructure</a></h2>
<p>The Cargo project uses several bots:</p>
<ul>
<li><a href="https://github.com/features/actions">GitHub Actions</a> are used to automatically run all tests for each PR.</li>
<li><a href="https://github.com/rust-lang/triagebot/wiki">triagebot</a> automatically assigns reviewers for PRs, see <a href="https://github.com/rust-lang/triagebot/wiki/Assignment">Assignment</a> for
how to configure.</li>
<li><a href="https://buildbot2.rust-lang.org/homu/">bors</a> is used to merge PRs. See <a href="process/working-on-cargo.html#the-merging-process">The merging process</a>.</li>
<li><a href="https://github.com/rust-lang/triagebot/wiki">triagebot</a> is used for assigning issues to non-members, see <a href="process/index.html#issue-assignment">Issue
assignment</a>.</li>
<li><a href="https://github.com/rust-lang/rfcbot-rs">rfcbot</a> is used for making asynchronous decisions by team members.</li>
</ul>
<h2 id="issue-assignment"><a class="header" href="#issue-assignment">Issue assignment</a></h2>
<p>Normally, if you plan to work on an issue that has been marked with one of the
<code>E-</code> tags or <a href="https://github.com/rust-lang/cargo/labels/Feature%20accepted">Feature accepted</a>, it is sufficient just to leave a comment that
you are working on it. We also have a bot that allows you to formally “claim”
an issue by entering the text <code>@rustbot claim</code> in a comment. See the
<a href="https://github.com/rust-lang/triagebot/wiki/Assignment">Assignment</a> docs on how this works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-on-cargo"><a class="header" href="#working-on-cargo">Working on Cargo</a></h1>
<p>This chapter gives an overview of how to build Cargo, make a change, and
submit a Pull Request.</p>
<ol start="0">
<li><a href="process/working-on-cargo.html#before-hacking-on-cargo">Before hacking on Cargo.</a></li>
<li><a href="process/working-on-cargo.html#checkout-out-the-source">Check out the Cargo source.</a></li>
<li><a href="process/working-on-cargo.html#building-cargo">Building Cargo.</a></li>
<li><a href="process/working-on-cargo.html#making-a-change">Making a change.</a></li>
<li><a href="process/../tests/index.html">Writing and running tests.</a></li>
<li><a href="process/working-on-cargo.html#submitting-a-pull-request">Submitting a Pull Request.</a></li>
<li><a href="process/working-on-cargo.html#the-merging-process">The merging process.</a></li>
</ol>
<h2 id="before-hacking-on-cargo"><a class="header" href="#before-hacking-on-cargo">Before hacking on Cargo</a></h2>
<p>We encourage people to discuss their design before hacking on code. This gives
the Cargo team a chance to know your idea more. Sometimes after a discussion,
we even find a way to solve the problem without coding! Typically, you
<a href="https://github.com/rust-lang/cargo/issues">file an issue</a> or start a thread on the <a href="https://internals.rust-lang.org/c/tools-and-infrastructure/cargo">internals forum</a> before submitting a
pull request. Please read <a href="process/index.html">the process</a> of how features and bugs are managed in
Cargo.</p>
<h2 id="checkout-out-the-source"><a class="header" href="#checkout-out-the-source">Checkout out the source</a></h2>
<p>We use the “fork and pull” model <a href="https://help.github.com/articles/about-collaborative-development-models/">described here</a>, where
contributors push changes to their personal fork and <a href="https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request">create pull requests</a> to
bring those changes into the source repository. Cargo uses <a href="https://git-scm.com/">git</a> and <a href="https://github.com/">GitHub</a>
for all development.</p>
<ol>
<li>Fork the <a href="https://github.com/rust-lang/cargo/"><code>rust-lang/cargo</code></a> repository on GitHub to your personal account
(see <a href="https://docs.github.com/en/github/getting-started-with-github/fork-a-repo">GitHub docs</a>).</li>
<li>Clone your fork to your local machine using <code>git clone</code> (see <a href="https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository">GitHub
docs</a>)</li>
<li>It is recommended to start a new branch for the change you want to make.
All Pull Requests are made against the master branch.</li>
</ol>
<h2 id="building-cargo"><a class="header" href="#building-cargo">Building Cargo</a></h2>
<p>Cargo is built by…running <code>cargo</code>! There are a few prerequisites that you
need to have installed:</p>
<ul>
<li><code>rustc</code> and <code>cargo</code> need to be installed. Cargo is expected to build and
test with the current stable, beta, and nightly releases. It is your choice
which to use. Nightly is recommended, since some nightly-specific tests are
disabled when using the stable release. But using stable is fine if you
aren’t working on those.</li>
<li>A C compiler (typically gcc, clang, or MSVC).</li>
<li><a href="https://git-scm.com/">git</a></li>
<li>Unix:
<ul>
<li>pkg-config</li>
<li>OpenSSL (<code>libssl-dev</code> on Ubuntu, <code>openssl-devel</code> on Fedora)</li>
</ul>
</li>
<li>macOS:
<ul>
<li>OpenSSL (<a href="https://brew.sh/">homebrew</a> is recommended to install the <code>openssl</code> package)</li>
</ul>
</li>
</ul>
<p>If you can successfully run <code>cargo build</code>, you should be good to go!</p>
<h2 id="running-cargo"><a class="header" href="#running-cargo">Running Cargo</a></h2>
<p>You can use <code>cargo run</code> to run cargo itself, or you can use the path directly
to the cargo binary, such as <code>target/debug/cargo</code>.</p>
<p>If you are using <a href="https://rust-lang.github.io/rustup/"><code>rustup</code></a>, beware that running the binary directly can cause
issues with rustup overrides. Usually, when <code>cargo</code> is executed as part of
rustup, the toolchain becomes sticky (via an environment variable), and all
calls to <code>rustc</code> will use the same toolchain. But when <code>cargo</code> is not run via
rustup, the toolchain may change based on the directory. Since Cargo changes
the directory for each compilation, this can cause different calls to <code>rustc</code>
to use different versions. There are a few workarounds:</p>
<ul>
<li>Don’t use rustup overrides.</li>
<li>Use <code>rustup run target/debug/cargo</code> to execute <code>cargo</code>.</li>
<li>Set the <code>RUSTC</code> environment variable to a specific <code>rustc</code> executable (not
the rustup wrapper).</li>
<li>Create a <a href="https://rust-lang.github.io/rustup/concepts/toolchains.html#custom-toolchains">custom toolchain</a>. This is a bit of a hack, but you can create a
directory in the rustup <code>toolchains</code> directory, and create symlinks for all
the files and directories in there to your toolchain of choice (such as
nightly), except for the <code>cargo</code> binary, which you can symlink to your
<code>target/debug/cargo</code> binary in your project directory.</li>
</ul>
<p><em>Normally</em>, all development is done by running Cargo’s test suite, so running
it directly usually isn’t required. But it can be useful for testing Cargo on
more complex projects.</p>
<h2 id="making-a-change"><a class="header" href="#making-a-change">Making a change</a></h2>
<p>Some guidelines on working on a change:</p>
<ul>
<li>All code changes are expected to comply with the formatting suggested by
<code>rustfmt</code>. You can use <code>rustup component add rustfmt</code> to install <code>rustfmt</code>
and use <code>cargo fmt</code> to automatically format your code.</li>
<li>Include tests that cover all non-trivial code. See the <a href="process/../tests/index.html">Testing chapter</a> for
more about writing and running tests.</li>
<li>All code should be warning-free. This is checked during tests.</li>
</ul>
<h2 id="submitting-a-pull-request"><a class="header" href="#submitting-a-pull-request">Submitting a Pull Request</a></h2>
<p>After you have committed your work, and pushed it to GitHub, you can
open a Pull Request</p>
<ul>
<li>Push your commits to GitHub and create a pull request against Cargo’s
<code>master</code> branch.</li>
<li>Include a clear description of what the change is and why it is being made.</li>
<li>Use <a href="https://docs.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue">GitHub’s keywords</a> in the description to automatically link to an issue
if the PR resolves the issue. For example <code>Closes #1234</code> will link issue
#1234 to the PR. When the PR is merged, GitHub will automatically close the
issue.</li>
</ul>
<p><a href="https://github.com/rustbot"><code>@rustbot</code></a> will automatically assign a reviewer for the PR. It
may take at least a few days for someone to respond. If you don’t get a
response in over a week, feel free to ping the assigned reviewer.</p>
<p>When your PR is submitted, GitHub automatically runs all tests. The GitHub
interface will show a green checkmark if it passes, or a red X if it fails.
There are links to the logs on the PR page to diagnose any issues. The tests
typically finish in under 30 minutes.</p>
<p>The reviewer might point out changes deemed necessary. Large or tricky changes
may require several passes of review and changes.</p>
<h3 id="status-labeling"><a class="header" href="#status-labeling">Status labeling</a></h3>
<p>PRs will get marked with <a href="https://github.com/rust-lang/cargo/labels">labels</a> like <a href="https://github.com/rust-lang/cargo/labels/S-waiting-on-review"><code>S-waiting-on-review</code></a> or <a href="https://github.com/rust-lang/cargo/labels/S-waiting-on-author"><code>S-waiting-on-author</code></a> to indicate their status.
The <a href="https://github.com/rustbot"><code>@rustbot</code></a> bot can be used by anyone to adjust the labels.
If a PR gets marked as <code>S-waiting-on-author</code>, and you have pushed new changes that you would like to be reviewed, you can write a comment on the PR with the text <code>@rustbot ready</code>.
The bot will switch the labels on the PR.</p>
<p>More information about these commands can be found at the <a href="https://github.com/rust-lang/triagebot/wiki/Shortcuts">shortcuts documentation</a>.</p>
<h2 id="the-merging-process"><a class="header" href="#the-merging-process">The merging process</a></h2>
<p>After a reviewer has approved your PR, they will issue a command to the <a href="https://buildbot2.rust-lang.org/homu/">bors</a>
bot (also known as “Homu”, the software that powers <a href="https://github.com/bors"><code>@bors</code></a>). Bors will
create a temporary branch with your PR, and run all tests. Only if all tests
pass will it merge the PR to master. If it fails, the bot will leave a comment
on the PR. This system ensures that the master branch is always in a good
state, and that merges are processed one at a time. The <a href="https://buildbot2.rust-lang.org/homu/queue/cargo">Homu queue
dashboard</a> shows the current merge queue. Cargo’s queue is rarely
busy, but a busy project like the <a href="https://buildbot2.rust-lang.org/homu/queue/rust">rust repo</a> is constantly full.</p>
<p>Assuming everything works, congratulations! It may take at least a week for
the changes to arrive on the nightly channel. See the <a href="process/release.html">release chapter</a> for
more information on how Cargo releases are made.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-process"><a class="header" href="#release-process">Release process</a></h1>
<p>Cargo is released with <code>rustc</code> using a <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">“train model”</a>. After a
change lands in Cargo’s master branch, it will be synced with the
<a href="https://github.com/rust-lang/rust/">rust-lang/rust</a> repository by a Cargo team member, which happens about once a
week. If there are complications, it can take longer. After it is synced and
merged, the changes will appear in the next nightly release, which is usually
published around 00:30 UTC.</p>
<p>After changes are in the nightly release, they will make their way to the
stable release anywhere from 6 to 12 weeks later, depending on when during the
cycle it landed.</p>
<p>The current release schedule is posted on the <a href="https://forge.rust-lang.org/">Rust Forge</a>. See the <a href="https://forge.rust-lang.org/release/process.html">release
process</a> for more details on how Rust’s releases are created. Rust releases
are managed by the <a href="https://www.rust-lang.org/governance/teams/operations#release">Release team</a>.</p>
<h2 id="build-process"><a class="header" href="#build-process">Build process</a></h2>
<p>The build process for Cargo is handled as part of building Rust. Every PR on
the <a href="https://github.com/rust-lang/rust/">rust-lang/rust</a> repository creates a full collection of release artifacts
for every platform. The code for this is in the <a href="https://github.com/rust-lang/rust/blob/master/src/bootstrap/dist.rs"><code>dist</code> bootstrap module</a>.
Every night at 00:00 UTC, the artifacts from the most recently merged PR are
promoted to the nightly release channel. A similar process happens for beta
and stable releases.</p>
<h2 id="submodule-updates"><a class="header" href="#submodule-updates">Submodule updates</a></h2>
<p>Cargo is tracked in the <a href="https://github.com/rust-lang/rust/">rust-lang/rust</a> repository using a <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">git submodule</a>.
It is updated manually about once a week by a Cargo team member.
However, anyone is welcome to update it as needed.</p>
<p><a href="https://github.com/ehuss/">@ehuss</a> has a tool called <a href="https://github.com/ehuss/subup">subup</a> to automate the process of updating the submodule, updating the lockfile, running tests, and creating a PR.
Running the tests ahead-of-time helps avoid long cycle times waiting for bors if there are any errors.
Subup will also provide a message to include in the PR with a list of all PRs it covers.
Posting this in the PR message also helps create reference links on each Cargo PR to the submodule update PR to help track when it gets merged.</p>
<p>The following is an example of the command to run in a local clone of rust-lang/rust to run a certain set of tests of things that are likely to get broken by a Cargo update:</p>
<pre><code class="language-bash">subup --up-branch update-cargo \
    --commit-message &quot;Update cargo&quot; \
    --test=&quot;src/tools/linkchecker tidy \
        src/tools/cargo \
        src/tools/rustfmt \
    src/tools/cargo
</code></pre>
<p>If doing a <a href="process/release.html#beta-backports">beta backport</a>, the command is similar, but needs to point to the correct branches:</p>
<pre><code class="language-bash">subup --up-branch update-beta-cargo \
    --rust-branch beta \
    --set-config rust.channel=beta \
    --commit-message &quot;[beta] Update cargo&quot; \
    --test=&quot;src/tools/linkchecker tidy \
        src/tools/cargo \
        src/tools/rustfmt \
    rust-1.66.0:src/tools/cargo
</code></pre>
<h2 id="version-updates"><a class="header" href="#version-updates">Version updates</a></h2>
<p>Shortly after each major release, a Cargo team member will post a PR to update
Cargo’s version in <code>Cargo.toml</code>. Cargo’s library is permanently unstable, so
its version number starts with a <code>0</code>. The minor version is always 1 greater
than the Rust release it is a part of, so cargo 0.49.0 is part of the 1.48
Rust release. The <a href="https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md">CHANGELOG</a> is also usually updated at this time.</p>
<p>Also, any version-specific checks that are no longer needed can be removed.
For example, some tests are disabled on stable if they require some nightly
behavior. Once that behavior is available on the new stable release, the
checks are no longer necessary. (I usually search for the word “nightly” in
the testsuite directory, and read the comments to see if any of those nightly
checks can be removed.)</p>
<p>Sometimes Cargo will have a runtime check to probe <code>rustc</code> if it supports a
specific feature. This is usually stored in the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/compiler/build_context/target_info.rs"><code>TargetInfo</code></a> struct. If this
behavior is now stable, those checks should be removed.</p>
<p>Cargo has several other packages in the <a href="https://github.com/rust-lang/cargo/tree/master/crates"><code>crates/</code> directory</a>. If any of these
packages have changed, the version should be bumped <strong>before the beta
release</strong>. It is rare that these get updated. Bumping these as-needed helps
avoid churning incompatible version numbers. This process should be improved
in the future!</p>
<p><a href="https://github.com/ehuss/">@ehuss</a> has a tool called <a href="https://github.com/ehuss/cargo-new-release">cargo-new-release</a> to automate the process of doing a version bump.
It runs through several steps:</p>
<ol>
<li>Creates a branch</li>
<li>Updates the version numbers</li>
<li>Creates a changelog for anything on the master branch that is not part of beta</li>
<li>Creates a changelog for anything on the beta branch</li>
</ol>
<p>It opens a browser tab for every PR in order to review each change.
It places each PR in the changelog with its title, but usually every PR should be rewritten to explain the change from the user’s perspective.
Each PR should also be categorized as an Addition, Change, Fix, or Nightly-only change.
Most PRs are deleted, since they are not relevant to users of Cargo.
For example, remove all PRs related to Cargo internals, infrastructure, documentation, error changes, refactorings, etc.
Usually about half of the PRs get removed.
This process usually takes @ehuss about an hour to finish.</p>
<h2 id="docs-publishing"><a class="header" href="#docs-publishing">Docs publishing</a></h2>
<p>Docs are automatically published during the Rust release process. The nightly
channel’s docs appear at <a href="https://doc.rust-lang.org/nightly/cargo/">https://doc.rust-lang.org/nightly/cargo/</a>. Once
nightly is promoted to beta, those docs will appear at
<a href="https://doc.rust-lang.org/beta/cargo/">https://doc.rust-lang.org/beta/cargo/</a>. Once the stable release is made, it
will appear on <a href="https://doc.rust-lang.org/cargo/">https://doc.rust-lang.org/cargo/</a> (which is the “current”
stable) and the release-specific URL such as
<a href="https://doc.rust-lang.org/1.46.0/cargo/">https://doc.rust-lang.org/1.46.0/cargo/</a>.</p>
<p>The code that builds the documentation is located in the <a href="https://github.com/rust-lang/rust/blob/master/src/bootstrap/doc.rs"><code>doc</code> bootstrap
module</a>.</p>
<h2 id="cratesio-publishing"><a class="header" href="#cratesio-publishing">crates.io publishing</a></h2>
<p>Cargo’s library is published to <a href="https://crates.io/">crates.io</a> as part of the stable release
process. This is handled by the <a href="https://www.rust-lang.org/governance/teams/operations#release">Release team</a> as part of their process. There
is a <a href="https://github.com/rust-lang/cargo/blob/master/publish.py"><code>publish.py</code> script</a> that in theory should help with this process. The
test and build tool crates aren’t published.</p>
<h2 id="beta-backports"><a class="header" href="#beta-backports">Beta backports</a></h2>
<p>If there is a regression or major problem detected during the beta phase, it
may be necessary to backport a fix to beta. The process is documented in the
<a href="https://forge.rust-lang.org/release/beta-backporting.html">Beta Backporting</a> page.</p>
<h2 id="stable-backports"><a class="header" href="#stable-backports">Stable backports</a></h2>
<p>In (hopefully!) very rare cases, a major regression or problem may be reported
after the stable release. Decisions about this are usually coordinated between
the <a href="https://www.rust-lang.org/governance/teams/operations#release">Release team</a> and the Cargo team. There is usually a high bar for making
a stable patch release, and the decision may be influenced by whether or not
there are other changes that need a new stable release.</p>
<p>The process here is similar to the beta-backporting process. The
<a href="https://github.com/rust-lang/cargo/">rust-lang/cargo</a> branch is the same as beta (<code>rust-1.XX.0</code>). The
<a href="https://github.com/rust-lang/rust/">rust-lang/rust</a> branch is called <code>stable</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unstable-features"><a class="header" href="#unstable-features">Unstable features</a></h1>
<p>Most new features should go through the unstable process. This means that the
feature will only be usable on the nightly channel, and requires a specific
opt-in by the user. Small changes can skip this process, but please consult
with the Cargo team first.</p>
<h2 id="unstable-feature-opt-in"><a class="header" href="#unstable-feature-opt-in">Unstable feature opt-in</a></h2>
<p>For features that require behavior changes or new syntax in <code>Cargo.toml</code>, then
it will need a <code>cargo-features</code> value placed at the top of <code>Cargo.toml</code> to
enable it. The process for doing adding a new feature is described in the
<a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/features.rs"><code>features</code> module</a>. Code that implements the feature will need to manually
check that the feature is enabled for the current manifest.</p>
<p>For features that add new command-line flags, config options, or environment
variables, then the <code>-Z</code> flags will be needed to enable them. The <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/features.rs"><code>features</code>
module</a> also describes how to add these. New flags should use the
<code>fail_if_stable_opt</code> method to check if the <code>-Z unstable-options</code> flag has
been passed.</p>
<h2 id="unstable-documentation"><a class="header" href="#unstable-documentation">Unstable documentation</a></h2>
<p>Every unstable feature should have a section added to the <a href="https://github.com/rust-lang/cargo/blob/master/src/doc/src/reference/unstable.md">unstable chapter</a>
describing how to use the feature.</p>
<h2 id="tracking-issues"><a class="header" href="#tracking-issues">Tracking issues</a></h2>
<p>Each unstable feature should get a <a href="https://github.com/rust-lang/cargo/labels/C-tracking-issue">tracking issue</a>. These issues are
typically created when a PR is close to being merged, or soon after it is
merged. Use the <a href="https://github.com/rust-lang/cargo/issues/new?labels=C-tracking-issue&amp;template=tracking_issue.md">tracking issue template</a> when creating a tracking issue.</p>
<p>Larger features should also get a new label in the issue tracker so that when
issues are filed, they can be easily tied together.</p>
<h2 id="pre-stabilization"><a class="header" href="#pre-stabilization">Pre-Stabilization</a></h2>
<p>Once an unstable feature is “complete”, the search for users to test
and give feedback begins. Testing notes should be written up to give users an
idea of how to test the new feature. An example being the 
<a href="https://github.com/rust-lang/cargo/blob/6d6dd9d9be9c91390da620adf43581619c2fa90e/src/doc/src/reference/unstable.md#testing-notes">workspace inheritance testing notes</a> for workspace inheritance. Once testing
notes have been written up you should make posts in various rust communities
(<a href="https://www.reddit.com/r/rust/">rust subreddit</a>, <a href="https://users.rust-lang.org/">users</a>, <a href="https://internals.rust-lang.org/">internals</a>, etc). Example posts made for workspace
inheritance: <a href="https://www.reddit.com/r/rust/comments/uo8zeh/help_test_workspace_inheritance_in_preparation/">reddit post</a>, <a href="https://users.rust-lang.org/t/help-test-workspace-inheritance-in-preparation-for-stablization/75582">users post</a>, <a href="https://internals.rust-lang.org/t/help-test-workspace-inheritance-in-preparation-for-stablization/16618">internals post</a>. The unstable feature
should also be added to <a href="https://this-week-in-rust.org/">This Week in Rust</a>. This should be done by adding the
label <code>call-for-testing</code> to the RFC for the feature and making a comment with a
link to the testing notes and the tracking issue (as needed). If there is not an
RFC, a pull request should be made to the <a href="https://github.com/rust-lang/this-week-in-rust">TWiR repo</a> adding the feature to the
<code>Call for Testing</code> section (<a href="https://github.com/rust-lang/this-week-in-rust/pull/3256">example</a>).</p>
<h2 id="stabilization"><a class="header" href="#stabilization">Stabilization</a></h2>
<p>After some period of time, typically measured in months, the feature can be
considered to be stabilized. The feature should not have any significant known
bugs or issues, and any design concerns should be resolved.</p>
<p>The stabilization process depends on the kind of feature. For smaller
features, you can leave a comment on the tracking issue expressing interest in
stabilizing it. It can usually help to indicate that the feature has received
some real-world testing, and has exhibited some demand for broad use.</p>
<p>For larger features that have not gone through the <a href="https://github.com/rust-lang/rfcs/">RFC process</a>, then an RFC
to call for stabilization might be warranted. This gives the community a final
chance to provide feedback about the proposed design.</p>
<p>For a small feature, or one that has already gone through the RFC process, a
Cargo Team member may decide to call for a “final comment period” using
<a href="https://github.com/rust-lang/rfcbot-rs">rfcbot</a>. This is a public signal that a major change is being made, and gives
the Cargo Team members an opportunity to confirm or block the change. This
process can take a few days or weeks, or longer if a concern is raised.</p>
<p>Once the stabilization has been approved, the person who called for
stabilization should prepare a PR to stabilize the feature. This PR should:</p>
<ul>
<li>Flip the feature to stable in the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/features.rs"><code>features</code> module</a>.</li>
<li>Remove any unstable checks that aren’t automatically handled by the feature
system.</li>
<li>Move the documentation from the <a href="https://github.com/rust-lang/cargo/blob/master/src/doc/src/reference/unstable.md">unstable chapter</a> into the appropriate
places in the Cargo book and man pages.</li>
<li>Remove the <code>-Z</code> flags and help message if applicable.</li>
<li>Update all tests to remove nightly checks.</li>
<li>Tag the PR with <a href="https://github.com/rust-lang/cargo/issues?q=label%3Arelnotes">relnotes</a> label if it seems important enough to highlight
in the <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md">Rust release notes</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h1>
<p>The purpose of Cargo is to formalize a canonical Rust workflow, by automating
the standard tasks associated with distributing software. Cargo simplifies
structuring a new project, adding dependencies, writing and running unit
tests, and more.</p>
<p>Cargo is not intended to be a general-purpose build tool. Ideally, it should
be easy to integrate it within another build tool, though admittedly that is
not as seamless as desired.</p>
<h2 id="stability-and-compatibility"><a class="header" href="#stability-and-compatibility">Stability and compatibility</a></h2>
<h3 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards compatibility</a></h3>
<p>Cargo strives to remain backwards compatible with projects created in previous
versions. The CLI interface also strives to remain backwards compatible, such
that the commands and options behave the same. That being said, changes in
behavior, and even outright breakage are sometimes done in limited situations.
The following outlines some situations where backwards-incompatible changes are
made:</p>
<ul>
<li>Anything that addresses a security concern.</li>
<li>Dropping support for older platforms and tooling. Cargo follows the Rust
<a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">tiered platform support</a>.</li>
<li>Changes to resolve possibly unsafe or unreliable behavior.</li>
</ul>
<p>None of these changes should be taken lightly, and should be avoided if
possible, or possibly with some transition period to alert the user of the
potential change.</p>
<p>Behavior is sometimes changed in ways that have a high confidence that it
won’t break existing workflows. Almost every change carries this risk, so it
is often a judgment call balancing the benefit of the change with the
perceived possibility of its negative consequences.</p>
<p>At times, some changes fall in the gray area, where the current behavior is
undocumented, or not working as intended. These are more difficult judgment
calls. The general preference is to balance towards avoiding breaking existing
workflows.</p>
<p>Support for older registry APIs and index formats may be dropped, if there is
high confidence that there aren’t any active registries that may be affected.
This has never (to my knowledge) happened so far, and is unlikely to happen in
the future, but remains a possibility.</p>
<p>In all of the above, a transition period may be employed if a change is known
to cause breakage. A warning can be issued to alert the user that something
will change, and provide them with an alternative to resolve the issue
(preferably in a way that is compatible across versions if possible).</p>
<p>Cargo is only expected to work with the version of the related Rust tools
(<code>rustc</code>, <code>rustdoc</code>, etc.) that it is released with. As a matter of choice,
the latest nightly works with the most recent stable release, but that is
mostly to accommodate development of Cargo itself, and should not be expected
by users.</p>
<h3 id="forwards-compatibility"><a class="header" href="#forwards-compatibility">Forwards compatibility</a></h3>
<p>Additionally, Cargo strives a limited degree of <em>forwards compatibility</em>.
Changes should not egregiously prevent older versions from working. This is
mostly relevant for persistent data, such as on-disk files and the registry
interface and index. It also applies to a lesser degree to the registry API.</p>
<p>Changes to <code>Cargo.lock</code> require a transition time, where the new format is not
automatically written when the lock file is updated. The transition time
should not be less than 6 months, though preferably longer. New projects may
use the new format in a shorter time frame.</p>
<p>Changes to <code>Cargo.toml</code> can be made in any release. This is because the user
must manually modify the file, and opt-in to any new changes. Additionally,
Cargo will usually only issue a warning about new fields it doesn’t
understand, but otherwise continue to function.</p>
<p>Changes to cache files (such as artifacts in the <code>target</code> directory, or cached
data in Cargo’s home directory) should not <em>prevent</em> older versions from
running, but they may cause older versions to recreate the cache, which may
result in a performance impact.</p>
<p>Changes to the registry index should not prevent older versions from working.
Generally, older versions ignore new fields, so the format should be easily
extensible. Changes to the format or interpretation of existing fields should
be done very carefully to avoid preventing older versions of Cargo from
working. In some cases, this may mean that older versions of Cargo will not be
able to <em>select</em> a newly published crate, but it shouldn’t prevent them from
working at all. This level of compatibility may not last forever, but the
exact time frame for such a change has not yet been decided.</p>
<p>The registry API may be changed in such a way to prevent older versions of
Cargo from working. Generally, compatibility should be retained for as long as
possible, but the exact length of time is not specified.</p>
<h2 id="simplicity-and-layers"><a class="header" href="#simplicity-and-layers">Simplicity and layers</a></h2>
<p>Standard workflows should be easy and consistent. Each knob that is added has
a high cost, regardless if it is intended for a small audience. Layering and
defaults can help avoid the surface area that the user needs to be concerned
with. Try to avoid small functionalities that may have complex interactions
with one another.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>This chapter gives a very high-level overview of Cargo’s architecture. This is
intended to give you links into the code which is hopefully commented with
more in-depth information.</p>
<p>If you feel something is missing that would help you, feel free to ask on
<a href="https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo">Zulip</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="codebase-overview"><a class="header" href="#codebase-overview">Codebase Overview</a></h1>
<p>See <a href="https://doc.rust-lang.org/nightly/nightly-rustc/cargo/index.html">nightly docs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subcommands"><a class="header" href="#subcommands">SubCommands</a></h1>
<p>Cargo is a single binary composed of a set of <a href="https://clap.rs/"><code>clap</code></a> subcommands. All
subcommands live in <a href="https://github.com/rust-lang/cargo/tree/master/src/bin/cargo/commands"><code>src/bin/cargo/commands</code></a> directory.
<a href="https://github.com/rust-lang/cargo/blob/master/src/bin/cargo/main.rs"><code>src/bin/cargo/main.rs</code></a> is the entry point.</p>
<p>Each subcommand, such as <a href="https://github.com/rust-lang/cargo/tree/master/src/bin/cargo/commands/build.rs"><code>src/bin/cargo/commands/build.rs</code></a>, usually performs
the following:</p>
<ol>
<li>Parse the CLI flags. See the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/util/command_prelude.rs"><code>command_prelude</code></a> module for some helpers to make this easier.</li>
<li>Load the config files.</li>
<li>Discover and load the workspace.</li>
<li>Calls the actual implementation of the subcommand which resides in <a href="https://github.com/rust-lang/cargo/tree/master/src/cargo/ops"><code>src/cargo/ops</code></a>.</li>
</ol>
<p>If the subcommand is not found in the built-in list, then Cargo will
automatically search for a subcommand named <code>cargo-{NAME}</code> in the users <code>PATH</code>
to execute the subcommand.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="console-output"><a class="header" href="#console-output">Console Output</a></h1>
<p>All of Cargo’s output should go through the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/shell.rs"><code>Shell</code></a> struct. You can normally
obtain the <code>Shell</code> instance from the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/util/config/mod.rs"><code>Config</code></a> struct. Do <strong>not</strong> use the std
<code>println!</code> macros.</p>
<p>Most of Cargo’s output goes to stderr. When running in JSON mode, the output
goes to stdout.</p>
<p>It is important to properly handle errors when writing to the console.
Informational commands, like <code>cargo list</code>, should ignore any errors writing
the output. There are some <a href="https://github.com/rust-lang/cargo/blob/e4b65bdc80f2a293447f2f6a808fa7c84bf9a357/src/cargo/util/config/mod.rs#L1820-L1848"><code>drop_print</code></a> macros that are intended to make
this easier.</p>
<p>Messages written during compilation should handle errors, and abort the build
if they are unable to be displayed. This is generally automatically handled in
the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/compiler/job_queue.rs"><code>JobQueue</code></a> as it processes each message.</p>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<p>Cargo uses <a href="https://docs.rs/anyhow"><code>anyhow</code></a> for managing errors. This makes it convenient to “chain”
errors together, so that Cargo can report how an error originated, and what it
was trying to do at the time.</p>
<p>Error helpers are implemented in the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/util/errors.rs"><code>errors</code></a> module. Use the
<code>InternalError</code> error type for errors that are not expected to happen. This
will print a message to the user to file a bug report.</p>
<p>The binary side of Cargo uses the <code>CliError</code> struct to wrap the process exit
code. Usually Cargo exits with 101 for an error, but some commands like <code>cargo test</code> will exit with different codes.</p>
<h2 id="style"><a class="header" href="#style">Style</a></h2>
<p>Some guidelines for Cargo’s output:</p>
<ul>
<li>Keep the normal output brief. Cargo is already fairly noisy, so try to keep
the output as brief and clean as possible.</li>
<li>Good error messages are very important! Try to keep them brief and to the
point, but good enough that a beginner can understand what is wrong and can
figure out how to fix. It is a difficult balance to hit! Err on the side of
providing extra information.</li>
<li>When using any low-level routines, such as <code>std::fs</code>, <em>always</em> add error
context about what it is doing. For example, reading from a file should
include context about which file is being read if there is an error.</li>
<li>Cargo’s error style is usually a phrase, starting with a lowercase letter.
If there is a longer error message that needs multiple sentences, go ahead
and use multiple sentences. This should probably be improved sometime in the
future to be more structured.</li>
</ul>
<h2 id="debug-logging"><a class="header" href="#debug-logging">Debug logging</a></h2>
<p>Cargo uses the <a href="https://docs.rs/env_logger"><code>env_logger</code></a> crate to display debug log messages. The
<code>CARGO_LOG</code> environment variable can be set to enable debug logging, with a
value such as <code>trace</code>, <code>debug</code>, or <code>warn</code>. It also supports filtering for
specific modules. Feel free to use the standard <a href="https://docs.rs/log"><code>log</code></a> macros to help with
diagnosing problems.</p>
<pre><code class="language-sh"># Outputs all logs with levels debug and higher
CARGO_LOG=debug cargo generate-lockfile

# Don't forget that you can filter by module as well
CARGO_LOG=cargo::core::resolver=trace cargo generate-lockfile

# This will print lots of info about the download process. `trace` prints even more.
CARGO_HTTP_DEBUG=true CARGO_LOG=cargo::ops::registry=debug cargo fetch

# This is an important command for diagnosing fingerprint issues.
CARGO_LOG=cargo::core::compiler::fingerprint=trace cargo build
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages-and-resolution"><a class="header" href="#packages-and-resolution">Packages and Resolution</a></h1>
<h2 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h2>
<p>The <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/workspace.rs"><code>Workspace</code></a> object is usually created very early by calling the
<a href="https://github.com/rust-lang/cargo/blob/e4b65bdc80f2a293447f2f6a808fa7c84bf9a357/src/cargo/util/command_prelude.rs#L298-L318"><code>workspace</code></a> helper method. This discovers the root of the
workspace, and loads all the workspace members as a <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/package.rs"><code>Package</code></a> object. Each
package corresponds to a single <code>Cargo.toml</code> (which is deserialized into a
<a href="https://github.com/rust-lang/cargo/blob/e4b65bdc80f2a293447f2f6a808fa7c84bf9a357/src/cargo/core/manifest.rs#L27-L51"><code>Manifest</code></a>), and may define several <a href="https://github.com/rust-lang/cargo/blob/e4b65bdc80f2a293447f2f6a808fa7c84bf9a357/src/cargo/core/manifest.rs#L181-L206"><code>Target</code></a>s, such as the library,
binaries, integration test or examples. Targets are crates (each target
defines a crate root, like <code>src/lib.rs</code> or <code>examples/foo.rs</code>) and are what is
actually compiled by <code>rustc</code>.</p>
<h2 id="packages-and-sources"><a class="header" href="#packages-and-sources">Packages and Sources</a></h2>
<p>There are several data structures that are important to understand how
packages are found and loaded:</p>
<ul>
<li><a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/package.rs"><code>Package</code></a> — A package, which is a <code>Cargo.toml</code> manifest and its associated
source files.
<ul>
<li><a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/package_id.rs"><code>PackageId</code></a> — A unique identifier for a package.</li>
</ul>
</li>
<li><a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/source/mod.rs"><code>Source</code></a> — An abstraction for something that can fetch packages (a remote
registry, a git repo, the local filesystem, etc.). Check out the <a href="https://github.com/rust-lang/cargo/tree/master/src/cargo/sources">source
implementations</a> for all the details about registries, indexes, git
dependencies, etc.
<ul>
<li><a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/source/source_id.rs"><code>SourceId</code></a> — A unique identifier for a source.</li>
</ul>
</li>
<li><a href="https://github.com/rust-lang/cargo/blob/e4b65bdc80f2a293447f2f6a808fa7c84bf9a357/src/cargo/core/source/mod.rs#L245-L249"><code>SourceMap</code></a> — Map of all available sources.</li>
<li><a href="https://github.com/rust-lang/cargo/blob/e4b65bdc80f2a293447f2f6a808fa7c84bf9a357/src/cargo/core/registry.rs#L36-L81"><code>PackageRegistry</code></a> — This is the main interface for how the dependency
resolver finds packages. It contains the <code>SourceMap</code>, and handles things
like the <code>[patch]</code> table. The <code>Registry</code> trait provides a generic interface
to the <code>PackageRegistry</code>, but this is only used for providing an alternate
implementation of the <code>PackageRegistry</code> for testing. The dependency resolver
sends a query to the <code>PackageRegistry</code> to “get me all packages that match
this dependency declaration”.</li>
<li><a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/summary.rs"><code>Summary</code></a> — A summary is a subset of a <a href="https://github.com/rust-lang/cargo/blob/e4b65bdc80f2a293447f2f6a808fa7c84bf9a357/src/cargo/core/manifest.rs#L27-L51"><code>Manifest</code></a>, and is essentially
the information that can be found in a registry index. Queries against the
<code>PackageRegistry</code> yields a <code>Summary</code>. The resolver uses the summary
information to build the dependency graph.</li>
<li><a href="https://github.com/rust-lang/cargo/blob/e4b65bdc80f2a293447f2f6a808fa7c84bf9a357/src/cargo/core/package.rs#L283-L296"><code>PackageSet</code></a> — Contains all of the <code>Package</code> objects. This works with the
<a href="https://github.com/rust-lang/cargo/blob/e4b65bdc80f2a293447f2f6a808fa7c84bf9a357/src/cargo/core/package.rs#L298-L352"><code>Downloads</code></a> struct to coordinate downloading packages. It has a reference
to the <code>SourceMap</code> to get the <code>Source</code> objects which tell the <code>Downloads</code>
struct which URLs to fetch.</li>
</ul>
<p>All of these come together in the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/ops/resolve.rs"><code>ops::resolve</code></a> module. This module
contains the primary functions for performing resolution (described below). It
also handles downloading of packages. It is essentially where all of the data
structures above come together.</p>
<h2 id="resolver"><a class="header" href="#resolver">Resolver</a></h2>
<p><a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/resolver/resolve.rs"><code>Resolve</code></a> is the representation of a directed graph of package dependencies,
which uses <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/package_id.rs"><code>PackageId</code></a>s for nodes. This is the data structure that is saved
to the <code>Cargo.lock</code> file. If there is no lock file, Cargo constructs a resolve
by finding a graph of packages which matches declared dependency specification
according to SemVer.</p>
<p><a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/ops/resolve.rs"><code>ops::resolve</code></a> is the front-end for creating a <code>Resolve</code>. It handles loading
the <code>Cargo.lock</code> file, checking if it needs updating, etc.</p>
<p>Resolution is currently performed twice. It is performed once with all
features enabled. This is the resolve that gets saved to <code>Cargo.lock</code>. It then
runs again with only the specific features the user selected on the
command-line. Ideally this second run will get removed in the future when
transitioning to the new feature resolver.</p>
<h3 id="feature-resolver"><a class="header" href="#feature-resolver">Feature resolver</a></h3>
<p>A new feature-specific resolver was added in 2020 which adds more
sophisticated feature resolution. It is located in the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/resolver/features.rs#L259"><code>resolver::features</code></a>
module. The original dependency resolver still performs feature unification,
as it can help reduce the dependencies it has to consider during resolution
(rather than assuming every optional dependency of every package is enabled).
Checking if a feature is enabled must go through the new feature resolver.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation"><a class="header" href="#compilation">Compilation</a></h1>
<p>See <a href="https://doc.rust-lang.org/nightly/nightly-rustc/cargo/ops/cargo_compile/index.html">nightly docs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="files"><a class="header" href="#files">Files</a></h1>
<p>This chapter gives some pointers on where to start looking at Cargo’s on-disk
data file structures.</p>
<ul>
<li><a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/compiler/layout.rs"><code>Layout</code></a> is the abstraction for the <code>target</code> directory. It handles locking
the target directory, and providing paths to the parts inside. There is a
separate <code>Layout</code> for each “target”.</li>
<li><a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/resolver/resolve.rs"><code>Resolve</code></a> contains the contents of the <code>Cargo.lock</code> file. See the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/resolver/encode.rs"><code>encode</code></a>
module for the different <code>Cargo.lock</code> formats.</li>
<li><a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/util/toml/mod.rs"><code>TomlManifest</code></a> contains the contents of the <code>Cargo.toml</code> file. It is translated
to a <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/manifest.rs"><code>Manifest</code></a> object for some simplification, and the <code>Manifest</code> is stored
in a <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/package.rs"><code>Package</code></a>.</li>
<li>The <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/compiler/fingerprint.rs"><code>fingerprint</code></a> module deals with the fingerprint information stored in
<code>target/debug/.fingerprint</code>. This tracks whether or not a crate needs to be
rebuilt.</li>
<li><code>cargo install</code> tracks its installed files with some metadata in
<code>$CARGO_HOME</code>. The metadata is managed in the
<a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/ops/common_for_install_and_uninstall.rs"><code>common_for_install_and_uninstall</code></a> module.</li>
<li>Git sources are cached in <code>$CARGO_HOME/git</code>. The code for this cache is in
the <a href="https://github.com/rust-lang/cargo/tree/master/src/cargo/sources/git"><code>git</code></a> source module.</li>
<li>Registries are cached in <code>$CARGO_HOME/registry</code>. There are three parts, the
index, the compressed <code>.crate</code> files, and the extracted sources of those
crate files.
<ul>
<li>Management of the registry cache can be found in the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/sources/registry/mod.rs"><code>registry</code></a> source
module. Note that this includes an on-disk cache as an optimization for
accessing the git repository.</li>
<li>Saving of <code>.crate</code> files is handled by the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/sources/registry/remote.rs"><code>RemoteRegistry</code></a>.</li>
<li>Extraction of <code>.crate</code> files is handled by the <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/sources/registry/mod.rs"><code>RegistrySource</code></a>.</li>
<li>There is a lock for the package cache. Code must be careful, because
this lock must be obtained manually. See
<a href="https://github.com/rust-lang/cargo/blob/e4b65bdc80f2a293447f2f6a808fa7c84bf9a357/src/cargo/util/config/mod.rs#L1261-L1266"><code>Config::acquire_package_cache_lock</code></a>.</li>
</ul>
</li>
</ul>
<h2 id="filesystems"><a class="header" href="#filesystems">Filesystems</a></h2>
<p>Cargo tends to get run on a very wide array of file systems. Different file
systems can have a wide range of capabilities, and Cargo should strive to do
its best to handle them. Some examples of issues to deal with:</p>
<ul>
<li>Not all file systems support locking. Cargo tries to detect if locking is
supported, and if not, will ignore lock errors. This isn’t ideal, but it is
difficult to deal with.</li>
<li>The <a href="https://doc.rust-lang.org/std/fs/fn.canonicalize.html"><code>fs::canonicalize</code></a> function doesn’t work on all file systems
(particularly some Windows file systems). If that function is used, there
should be a fallback if it fails. This function will also return <code>\\?\</code>
style paths on Windows, which can have some issues (such as some tools not
supporting them, or having issues with relative paths).</li>
<li>Timestamps can be unreliable. The <a href="https://github.com/rust-lang/cargo/blob/master/src/cargo/core/compiler/fingerprint.rs"><code>fingerprint</code></a> module has a deeper
discussion of this. One example is that Docker cache layers will erase the
fractional part of the time stamp.</li>
<li>Symlinks are not always supported, particularly on Windows.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p>Cargo has an extensive test suite. Most of it is implemented as integration
tests in the <a href="https://github.com/rust-lang/cargo/tree/master/tests/testsuite/"><code>testsuite</code></a> directory. There are several other tests:</p>
<ul>
<li>Unit tests are scattered throughout.</li>
<li>The dependency resolver has its own set of tests in the <a href="https://github.com/rust-lang/cargo/tree/master/crates/resolver-tests"><code>resolver-tests</code></a>
directory.</li>
<li>All of the packages in the <a href="https://github.com/rust-lang/cargo/tree/master/crates"><code>crates</code></a> directory have their own set of tests.</li>
<li>The <a href="https://github.com/rust-lang/cargo/blob/master/tests/build-std/main.rs"><code>build-std</code></a> test is for the <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std">build-std feature</a>. It is separate since
it has some special requirements.</li>
<li>Documentation has a variety of tests, such as link validation, and the
<a href="https://github.com/rust-lang/cargo/tree/master/src/doc/semver-check">SemVer chapter validity checks</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h1>
<p>Using <code>cargo test</code> is usually sufficient for running the full test suite. This
can take a few minutes, so you may want to use more targeted flags to pick the
specific test you want to run, such as <code>cargo test --test testsuite -- check::check_success</code>.</p>
<h2 id="running-nightly-tests"><a class="header" href="#running-nightly-tests">Running nightly tests</a></h2>
<p>Some tests only run on the nightly toolchain, and will be ignored on other
channels. It is recommended that you run tests with both nightly and stable to
ensure everything is working as expected.</p>
<p>Some of the nightly tests require the <code>rustc-dev</code> and <code>llvm-tools-preview</code>
rustup components installed. These components include the compiler as a
library. This may already be installed with your nightly toolchain, but if it
isn’t, run <code>rustup component add rustc-dev llvm-tools-preview --toolchain=nightly</code>.</p>
<h2 id="running-cross-tests"><a class="header" href="#running-cross-tests">Running cross tests</a></h2>
<p>Some tests exercise cross compiling to a different target. This will require
you to install the appropriate target. This typically is the 32-bit target of
your host platform. For example, if your host is a 64-bit
<code>x86_64-unknown-linux-gnu</code>, then you should install the 32-bit target with
<code>rustup target add i686-unknown-linux-gnu</code>. If you don’t have the alternate
target installed, there should be an error message telling you what to do. You
may also need to install additional tools for the target. For example, on Ubuntu
you should install the <code>gcc-multilib</code> package.</p>
<p>If you can’t install an alternate target, you can set the
<code>CFG_DISABLE_CROSS_TESTS=1</code> environment variable to disable these tests. The
Windows cross tests only support the MSVC toolchain.</p>
<h2 id="running-build-std-tests"><a class="header" href="#running-build-std-tests">Running build-std tests</a></h2>
<p>The <code>build-std</code> tests are disabled by default, but you can run them by setting
the <code>CARGO_RUN_BUILD_STD_TESTS=1</code> environment variable and running <code>cargo test --test build-std</code>. This requires the nightly channel, and also requires the
<code>rust-src</code> component installed with <code>rustup component add rust-src --toolchain=nightly</code>.</p>
<h2 id="running-with-gitoxide-as-default-git-backend-in-tests"><a class="header" href="#running-with-gitoxide-as-default-git-backend-in-tests">Running with <code>gitoxide</code> as default git backend in tests</a></h2>
<p>By default, the <code>git2</code> backend is used for most git operations. As tests need to explicitly
opt-in to use nightly features and feature flags, adjusting all tests to run with nightly
and <code>-Zgitoxide</code> is unfeasible.</p>
<p>This is why the private environment variable named <code>__CARGO_USE_GITOXIDE_INSTEAD_OF_GIT2</code> can be
set while running tests to automatically enable the <code>-Zgitoxide</code> flag implicitly, allowing to
test <code>gitoxide</code> for the entire cargo test suite.</p>
<h2 id="running-public-network-tests"><a class="header" href="#running-public-network-tests">Running public network tests</a></h2>
<p>Some (very rare) tests involve connecting to the public internet.
These tests are disabled by default,
but you can run them by setting the <code>CARGO_PUBLIC_NETWORK_TESTS=1</code> environment variable.
Additionally our CI suite has a smoke test for fetching dependencies.
For most contributors, you will never need to bother with this.</p>
<h2 id="running-container-tests"><a class="header" href="#running-container-tests">Running container tests</a></h2>
<p>Tests marked with <code>container_test</code> involve running Docker to test more complex configurations.
These tests are disabled by default,
but you can run them by setting the <code>CARGO_CONTAINER_TESTS=1</code> environment variable.
You will need to have Docker installed and running to use these.</p>
<blockquote>
<p>Note: Container tests mostly do not work on Windows.</p>
<ul>
<li>The SSH tests require ssh-agent, but the two versions of ssh-agent
on Windows are not suitable for testing.
<ul>
<li>The Microsoft version of ssh-agent runs as a global service, and can’t be isolated per test.</li>
<li>The mingw/cygwin one can’t be accessed from a Windows executable like cargo.</li>
<li>Pageant similarly does not seem to have a way to isolate it (and I’m not certain it can be driven completely from the command-line).</li>
</ul>
</li>
</ul>
<p>The tests also can’t run on Windows CI because the Docker that is preinstalled doesn’t support Linux containers, and setting up Windows containers is a pain.</p>
<p>macOS should work with Docker installed and running,
but unfortunately the tests are not run on CI because Docker is not available.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h1>
<p>The following focuses on writing an integration test. However, writing unit
tests is also encouraged!</p>
<h2 id="testsuite"><a class="header" href="#testsuite">Testsuite</a></h2>
<p>Cargo has a wide variety of integration tests that execute the <code>cargo</code> binary
and verify its behavior, located in the <a href="https://github.com/rust-lang/cargo/tree/master/tests/testsuite/"><code>testsuite</code></a> directory.  The
<a href="https://github.com/rust-lang/cargo/blob/master/crates/cargo-test-support/src/lib.rs"><code>support</code></a> crate and <a href="https://docs.rs/snapbox/latest/snapbox/"><code>snapbox</code></a> contain many helpers to make this process easy.</p>
<p>There are two styles of tests that can roughly be categorized as</p>
<ul>
<li>functional tests
<ul>
<li>The fixture is programmatically defined</li>
<li>The assertions are regular string comparisons</li>
<li>Easier to share in an issue as a code block is completely self-contained</li>
<li>More resilient to insignificant changes though ui tests are easy to update when a change does occur</li>
</ul>
</li>
<li>ui tests
<ul>
<li>The fixture is file-based</li>
<li>The assertions use file-backed snapshots that can be updated with an env variable</li>
<li>Easier to review the expected behavior of the command as more details are included</li>
<li>Easier to get up and running from an existing project</li>
<li>Easier to reason about as everything is just files in the repo</li>
</ul>
</li>
</ul>
<p>These tests typically work by creating a temporary “project” with a
<code>Cargo.toml</code> file, executing the <code>cargo</code> binary process, and checking the
stdout and stderr output against the expected output.</p>
<h3 id="functional-tests"><a class="header" href="#functional-tests">Functional Tests</a></h3>
<p>Generally, a functional test will be placed in <code>tests/testsuite/&lt;command&gt;.rs</code> and will look roughly like:</p>
<pre><code class="language-rust ignore">#[cargo_test]
fn &lt;description&gt;() {
    let p = project()
        .file(&quot;src/main.rs&quot;, r#&quot;fn main() { println!(&quot;hi!&quot;); }&quot;#)
        .build();

    p.cargo(&quot;run --bin foo&quot;)
        .with_stderr(
            &quot;\
    [COMPILING] foo [..]
    [FINISHED] [..]
    [RUNNING] `target/debug/foo`
    &quot;,
        )
        .with_stdout(&quot;hi!&quot;)
        .run();
    }
}</code></pre>
<p>The <a href="tests/writing.html#cargo_test-attribute"><code>#[cargo_test]</code> attribute</a> is used in place of <code>#[test]</code> to inject some setup code.</p>
<p><a href="https://github.com/rust-lang/cargo/blob/d847468768446168b596f721844193afaaf9d3f2/crates/cargo-test-support/src/lib.rs#L196-L202"><code>ProjectBuilder</code></a> via <code>project()</code>:</p>
<ul>
<li>Each project is in a separate directory in the sandbox</li>
<li>If you do not specify a <code>Cargo.toml</code> manifest using <code>file()</code>, one is
automatically created with a project name of <code>foo</code> using <code>basic_manifest()</code>.</li>
</ul>
<p><a href="https://github.com/rust-lang/cargo/blob/d847468768446168b596f721844193afaaf9d3f2/crates/cargo-test-support/src/lib.rs#L531-L550"><code>Execs</code></a> via <code>p.cargo(...)</code>:</p>
<ul>
<li>This executes the command and evaluates different assertions
<ul>
<li>See <a href="https://github.com/rust-lang/cargo/blob/master/crates/cargo-test-support/src/compare.rs"><code>support::compare</code></a> for an explanation of the string pattern matching.
Patterns are used to make it easier to match against the expected output.</li>
</ul>
</li>
</ul>
<h4 id="cargo_test-attribute"><a class="header" href="#cargo_test-attribute"><code>#[cargo_test]</code> attribute</a></h4>
<p>The <code>#[cargo_test]</code> attribute injects code which does some setup before starting the test.
It will create a filesystem “sandbox” under the “cargo integration test” directory for each test, such as <code>/path/to/cargo/target/tmp/cit/t123/</code>.
The sandbox will contain a <code>home</code> directory that will be used instead of your normal home directory.</p>
<p>The <code>#[cargo_test]</code> attribute takes several options that will affect how the test is generated.
They are listed in parentheses separated with commas, such as:</p>
<pre><code class="language-rust ignore">#[cargo_test(nightly, reason = &quot;-Zfoo is unstable&quot;)]</code></pre>
<p>The options it supports are:</p>
<ul>
<li><code>nightly</code> — This will cause the test to be ignored if not running on the nightly toolchain.
This is useful for tests that use unstable options in <code>rustc</code> or <code>rustdoc</code>.
These tests are run in Cargo’s CI, but are disabled in rust-lang/rust’s CI due to the difficulty of updating both repos simultaneously.
A <code>reason</code> field is required to explain why it is nightly-only.</li>
<li><code>build_std_real</code> — This is a “real” <code>-Zbuild-std</code> test (in the <code>build_std</code> integration test).
This only runs on nightly, and only if the environment variable <code>CARGO_RUN_BUILD_STD_TESTS</code> is set (these tests on run on Linux).</li>
<li><code>build_std_mock</code> — This is a “mock” <code>-Zbuild-std</code> test (which uses a mock standard library).
This only runs on nightly, and is disabled for windows-gnu.</li>
<li><code>requires_</code> — This indicates a command that is required to be installed to be run.
For example, <code>requires_rustfmt</code> means the test will only run if the executable <code>rustfmt</code> is installed.
These tests are <em>always</em> run on CI.
This is mainly used to avoid requiring contributors from having every dependency installed.</li>
<li><code>&gt;=1.64</code> — This indicates that the test will only run with the given version of <code>rustc</code> or newer.
This can be used when a new <code>rustc</code> feature has been stabilized that the test depends on.
If this is specified, a <code>reason</code> is required to explain why it is being checked.</li>
<li><code>public_network_test</code> — This tests contacts the public internet.
These tests are disabled unless the <code>CARGO_PUBLIC_NETWORK_TESTS</code> environment variable is set.
Use of this should be <em>extremely rare</em>, please avoid using it if possible.
The hosts it contacts should have a relatively high confidence that they are reliable and stable (such as github.com), especially in CI.
The tests should be carefully considered for developer security and privacy as well.</li>
<li><code>container_test</code> — This indicates that it is a test that uses Docker.
These tests are disabled unless the <code>CARGO_CONTAINER_TESTS</code> environment variable is set.
This requires that you have Docker installed.
The SSH tests also assume that you have OpenSSH installed.
These should work on Linux, macOS, and Windows where possible.
Unfortunately these tests are not run in CI for macOS or Windows (no Docker on macOS, and Windows does not support Linux images).
See <a href="https://github.com/rust-lang/cargo/blob/master/crates/cargo-test-support/src/containers.rs"><code>crates/cargo-test-support/src/containers.rs</code></a> for more on writing these tests.</li>
<li><code>ignore_windows=&quot;reason&quot;</code> — Indicates that the test should be ignored on windows for the given reason.</li>
</ul>
<h4 id="testing-nightly-features"><a class="header" href="#testing-nightly-features">Testing Nightly Features</a></h4>
<p>If you are testing a Cargo feature that only works on “nightly” Cargo, then
you need to call <code>masquerade_as_nightly_cargo</code> on the process builder and pass 
the name of the feature as the reason, like this:</p>
<pre><code class="language-rust ignore">p.cargo(&quot;build&quot;).masquerade_as_nightly_cargo(&amp;[&quot;print-im-a-teapot&quot;])</code></pre>
<p>If you are testing a feature that only works on <em>nightly rustc</em> (such as
benchmarks), then you should use the <code>nightly</code> option of the <code>cargo_test</code>
attribute, like this:</p>
<pre><code class="language-rust ignore">#[cargo_test(nightly, reason = &quot;-Zfoo is unstable&quot;)]</code></pre>
<p>This will cause the test to be ignored if not running on the nightly toolchain.</p>
<h4 id="specifying-dependencies"><a class="header" href="#specifying-dependencies">Specifying Dependencies</a></h4>
<p>You should not write any tests that use the network such as contacting
crates.io. Typically, simple path dependencies are the easiest way to add a
dependency. Example:</p>
<pre><code class="language-rust ignore">let p = project()
    .file(&quot;Cargo.toml&quot;, r#&quot;
        [package]
        name = &quot;foo&quot;
        version = &quot;1.0.0&quot;

        [dependencies]
        bar = {path = &quot;bar&quot;}
    &quot;#)
    .file(&quot;src/lib.rs&quot;, &quot;extern crate bar;&quot;)
    .file(&quot;bar/Cargo.toml&quot;, &amp;basic_manifest(&quot;bar&quot;, &quot;1.0.0&quot;))
    .file(&quot;bar/src/lib.rs&quot;, &quot;&quot;)
    .build();</code></pre>
<p>If you need to test with registry dependencies, see
<a href="https://github.com/rust-lang/cargo/blob/d847468768446168b596f721844193afaaf9d3f2/crates/cargo-test-support/src/registry.rs#L311-L389"><code>support::registry::Package</code></a> for creating packages you can depend on.</p>
<p>If you need to test git dependencies, see <a href="https://github.com/rust-lang/cargo/blob/master/crates/cargo-test-support/src/git.rs"><code>support::git</code></a> to create a git
dependency.</p>
<h4 id="cross-compilation"><a class="header" href="#cross-compilation">Cross compilation</a></h4>
<p>There are some utilities to help support tests that need to work against a
target other than the host. See <a href="tests/running.html#running-cross-tests">Running cross
tests</a> for more an introduction on cross
compilation tests.</p>
<p>Tests that need to do cross-compilation should include this at the top of the
test to disable it in scenarios where cross compilation isn’t available:</p>
<pre><code class="language-rust ignore">if cargo_test_support::cross_compile::disabled() {
    return;
}</code></pre>
<p>The name of the target can be fetched with the <a href="https://github.com/rust-lang/cargo/blob/d58902e22e148426193cf3b8c4449fd3c05c0afd/crates/cargo-test-support/src/cross_compile.rs#L208-L225"><code>cross_compile::alternate()</code></a>
function. The name of the host target can be fetched with
<a href="https://github.com/rust-lang/cargo/blob/d58902e22e148426193cf3b8c4449fd3c05c0afd/crates/cargo-test-support/src/lib.rs#L1137-L1140"><code>cargo_test_support::rustc_host()</code></a>.</p>
<p>The cross-tests need to distinguish between targets which can <em>build</em> versus
those which can actually <em>run</em> the resulting executable. Unfortunately, macOS is
currently unable to run an alternate target (Apple removed 32-bit support a
long time ago). For building, <code>x86_64-apple-darwin</code> will target
<code>x86_64-apple-ios</code> as its alternate. However, the iOS target can only execute
binaries if the iOS simulator is installed and configured. The simulator is
not available in CI, so all tests that need to run cross-compiled binaries are
disabled on CI. If you are running on macOS locally, and have the simulator
installed, then it should be able to run them.</p>
<p>If the test needs to run the cross-compiled binary, then it should have
something like this to exit the test before doing so:</p>
<pre><code class="language-rust ignore">if cargo_test_support::cross_compile::can_run_on_host() {
    return;
}</code></pre>
<h3 id="ui-tests"><a class="header" href="#ui-tests">UI Tests</a></h3>
<p>UI Tests are a bit more spread out and generally look like:</p>
<p><code>tests/testsuite/&lt;command&gt;/mod.rs</code>:</p>
<pre><code class="language-rust ignore">mod &lt;case&gt;;</code></pre>
<p><code>tests/testsuite/&lt;command&gt;/&lt;case&gt;/mod.rs</code>:</p>
<pre><code class="language-rust ignore">use cargo_test_support::prelude::*;
use cargo_test_support::compare::assert_ui;
use cargo_test_support::Project;
use cargo_test_support::curr_dir;

#[cargo_test]
fn case() {
    let project = Project::from_template(curr_dir!().join(&quot;in&quot;));
    let project_root = project.root();
    let cwd = &amp;project_root;

    snapbox::cmd::Command::cargo_ui()
        .arg(&quot;run&quot;)
        .arg_line(&quot;--bin foo&quot;)
        .current_dir(cwd)
        .assert()
        .success()
        .stdout_matches_path(curr_dir!().join(&quot;stdout.log&quot;))
        .stderr_matches_path(curr_dir!().join(&quot;stderr.log&quot;));

    assert_ui().subset_matches(curr_dir!().join(&quot;out&quot;), &amp;project_root);
}</code></pre>
<p>Then populate</p>
<ul>
<li><code>tests/testsuite/&lt;command&gt;/&lt;case&gt;/in</code> with the project’s directory structure</li>
<li><code>tests/testsuite/&lt;command&gt;/&lt;case&gt;/out</code> with the files you want verified</li>
<li><code>tests/testsuite/&lt;command&gt;/&lt;case&gt;/stdout.log</code> with nothing</li>
<li><code>tests/testsuite/&lt;command&gt;/&lt;case&gt;/stderr.log</code> with nothing</li>
</ul>
<p><code>#[cargo_test]</code>:</p>
<ul>
<li>This is used in place of <code>#[test]</code></li>
<li>This attribute injects code which does some setup before starting the
test, creating a filesystem “sandbox” under the “cargo integration test”
directory for each test such as
<code>/path/to/cargo/target/cit/t123/</code></li>
<li>The sandbox will contain a <code>home</code> directory that will be used instead of your normal home directory</li>
</ul>
<p><code>Project</code>:</p>
<ul>
<li>The project is copied from a directory in the repo</li>
<li>Each project is in a separate directory in the sandbox</li>
</ul>
<p><a href="https://docs.rs/snapbox/latest/snapbox/cmd/struct.Command.html"><code>Command</code></a> via <code>Command::cargo_ui()</code>:</p>
<ul>
<li>Set up and run a command.</li>
</ul>
<p><a href="https://docs.rs/snapbox/latest/snapbox/cmd/struct.OutputAssert.html"><code>OutputAssert</code></a> via <code>Command::assert()</code>:</p>
<ul>
<li>Perform assertions on the result of the <a href="https://docs.rs/snapbox/latest/snapbox/cmd/struct.Command.html"><code>Command</code></a></li>
</ul>
<p><a href="https://docs.rs/snapbox/latest/snapbox/struct.Assert.html"><code>Assert</code></a> via <code>assert_ui()</code>:</p>
<ul>
<li>Verify the command modified the file system as expected</li>
</ul>
<h4 id="updating-snapshots"><a class="header" href="#updating-snapshots">Updating Snapshots</a></h4>
<p>The project, stdout, and stderr snapshots can be updated by running with the
<code>SNAPSHOTS=overwrite</code> environment variable, like:</p>
<pre><code class="language-console">$ SNAPSHOTS=overwrite cargo test
</code></pre>
<p>Be sure to check the snapshots to make sure they make sense.</p>
<h4 id="testing-nightly-features-1"><a class="header" href="#testing-nightly-features-1">Testing Nightly Features</a></h4>
<p>If you are testing a Cargo feature that only works on “nightly” Cargo, then
you need to call <code>masquerade_as_nightly_cargo</code> on the process builder and pass
the name of the feature as the reason, like this:</p>
<pre><code class="language-rust ignore">    snapbox::cmd::Command::cargo()
        .masquerade_as_nightly_cargo(&amp;[&quot;print-im-a-teapot&quot;])</code></pre>
<p>If you are testing a feature that only works on <em>nightly rustc</em> (such as
benchmarks), then you should use the <code>nightly</code> option of the <code>cargo_test</code>
attribute, like this:</p>
<pre><code class="language-rust ignore">#[cargo_test(nightly, reason = &quot;-Zfoo is unstable&quot;)]</code></pre>
<p>This will cause the test to be ignored if not running on the nightly toolchain.</p>
<h3 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-specific Notes</a></h3>
<p>When checking output, use <code>/</code> for paths even on Windows: the actual output
of <code>\</code> on Windows will be replaced with <code>/</code>.</p>
<p>Be careful when executing binaries on Windows. You should not rename, delete,
or overwrite a binary immediately after running it. Under some conditions
Windows will fail with errors like “directory not empty” or “failed to remove”
or “access is denied”.</p>
<h2 id="debugging-tests"><a class="header" href="#debugging-tests">Debugging tests</a></h2>
<p>In some cases, you may need to dig into a test that is not working as you
expect, or you just generally want to experiment within the sandbox
environment. The general process is:</p>
<ol>
<li>
<p>Build the sandbox for the test you want to investigate. For example:</p>
<p><code>cargo test --test testsuite -- features2::inactivate_targets</code>.</p>
</li>
<li>
<p>In another terminal, head into the sandbox directory to inspect the files and run <code>cargo</code> directly.</p>
<ol>
<li>
<p>The sandbox directories start with <code>t0</code> for the first test.</p>
<p><code>cd target/tmp/cit/t0</code></p>
</li>
<li>
<p>Set up the environment so that the sandbox configuration takes effect:</p>
<p><code>export CARGO_HOME=$(pwd)/home/.cargo</code></p>
</li>
<li>
<p>Most tests create a <code>foo</code> project, so head into that:</p>
<p><code>cd foo</code></p>
</li>
</ol>
</li>
<li>
<p>Run whatever cargo command you want. See <a href="tests/../process/working-on-cargo.html#running-cargo">Running Cargo</a> for more details
on running the correct <code>cargo</code> process. Some examples:</p>
<ul>
<li><code>/path/to/my/cargo/target/debug/cargo check</code></li>
<li>Using a debugger like <code>lldb</code> or <code>gdb</code>:
<ol>
<li><code>lldb /path/to/my/cargo/target/debug/cargo</code></li>
<li>Set a breakpoint, for example: <code>b generate_root_units</code></li>
<li>Run with arguments: <code>r check</code></li>
</ol>
</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarking-and-profiling"><a class="header" href="#benchmarking-and-profiling">Benchmarking and Profiling</a></h1>
<h2 id="internal-profiler"><a class="header" href="#internal-profiler">Internal profiler</a></h2>
<p>Cargo has a basic, hierarchical profiler built-in. The environment variable
<code>CARGO_PROFILE</code> can be set to an integer which specifies how deep in the
profile stack to print results for.</p>
<pre><code class="language-sh"># Output first three levels of profiling info
CARGO_PROFILE=3 cargo generate-lockfile
</code></pre>
<h2 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h2>
<h3 id="benchsuite"><a class="header" href="#benchsuite">Benchsuite</a></h3>
<p>Head over to the <a href="https://github.com/rust-lang/cargo/tree/master/benches"><code>benches</code>
directory</a> for more
information about the benchmarking suite.</p>
<h3 id="informal-benchmarking"><a class="header" href="#informal-benchmarking">Informal benchmarking</a></h3>
<p>The overhead for starting a build should be kept as low as possible
(preferably, well under 0.5 seconds on most projects and systems). Currently,
the primary parts that affect this are:</p>
<ul>
<li>Running the resolver.</li>
<li>Querying the index.</li>
<li>Checking git dependencies.</li>
<li>Scanning the local project.</li>
<li>Building the unit dependency graph.</li>
</ul>
<p>One way to test this is to use <a href="https://github.com/sharkdp/hyperfine">hyperfine</a>. This is a tool that can be used to
measure the difference between different commands and settings. Usually this
is done by measuring the time it takes for <code>cargo build</code> to finish in a large
project where the build is fresh (no actual compilation is performed). Just
run <code>cargo build</code> once before using hyperfine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crater"><a class="header" href="#crater">Crater</a></h1>
<p><a href="https://github.com/rust-lang/crater">Crater</a> is a tool for compiling and running tests for <em>every</em> crate on <a href="https://crates.io">crates.io</a> (and a few on GitHub).
It is mainly used for checking the extent of breakage when implementing potentially breaking changes and ensuring lack of breakage by running beta vs stable compiler versions.</p>
<p>Essentially it runs some <code>cargo</code> command on every crate twice; once against the “start” toolchain and again against the “end” toolchain.
For example, “start” could be the stable release, and “end” could be beta.
If it passes in “start” but fails with “end”, then that is reported as a regression.</p>
<p>There is a bot called <a href="https://github.com/rust-lang/crater/blob/master/docs/bot-usage.md">craterbot</a> which is used to run crater on hardware managed by the rust-lang organization.</p>
<p>Crater is run by the release team during the beta cycle.
If there are any regressions that look like they are caused by Cargo, they should contact the Cargo team to decide how to handle it.</p>
<h2 id="running-crater"><a class="header" href="#running-crater">Running crater</a></h2>
<p>If you have a change that you want to test before the beta release, or you want to test behavior that is not normally exercised by crater, you can do a manual run of crater.
Roughly the steps are:</p>
<ol>
<li>
<p>Create a branch with your changes.</p>
<p>In your clone of cargo, make the changes to incorporate whatever new thing you want to test and push it to a branch on your fork on GitHub.</p>
</li>
<li>
<p>Get a clone of <a href="https://github.com/rust-lang/rust">https://github.com/rust-lang/rust</a></p>
</li>
<li>
<p>Create a branch in your rust-lang/rust clone to add your changes.</p>
</li>
<li>
<p>Change the <code>src/tools/cargo</code> submodule to point to your new branch.</p>
<p>Modify <code>.gitmodules</code> to point to your clone and branch of cargo with the changes you want to test.
For example:</p>
<pre><code class="language-bash">git submodule set-url src/tools/cargo https://github.com/ehuss/cargo.git
git submodule set-branch --branch my-awesome-feature src/tools/cargo
git submodule update --remote src/tools/cargo
git add .gitmodules src/tools/cargo
git commit
</code></pre>
</li>
<li>
<p>Create an PR on rust-lang/rust.</p>
<p>Push your submodule changes to GitHub and make a PR.
Start the PR title with <code>[EXPERIMENT]</code> to make it clear what the PR is for and assign yourself or @ghost.</p>
</li>
<li>
<p>Make a “try” build.</p>
<p>A “try” build creates a full release of x86_64-unknown-linux-gnu and stores it on rust-lang servers.
This can be done with a comment <code>@bors try</code> on the PR (all Cargo team members should have permission to do this).</p>
</li>
<li>
<p>Run crater.</p>
<p>Look at the <a href="https://github.com/rust-lang/crater/blob/master/docs/bot-usage.md">craterbot</a> docs to determine the command that you want to run.
There are different modes like <code>check-only</code>, <code>build-and-test</code>, <code>rustdoc</code>, etc.</p>
<p>You can also choose how many crates to run against.
If you are uncertain if your cargo changes will work correctly, it might be a good idea to run against <code>top-100</code> first to check its behavior.
This will run much faster.
You can do a full run afterwards.</p>
<p>After the try build finishes (which should take a couple hours), ask someone to make a crater run.
The Cargo team does not have that permission, so just ask someone on Zulip.
They will need to write a comment to <code>@craterbot</code> with the command that you have specified.</p>
</li>
<li>
<p>Wait.</p>
<p>Crater can take anywhere from a few hours to a few weeks to run depending on how long the <a href="https://crater.rust-lang.org/">craterbot queue</a> is and which mode you picked and the priority of your job.
When the crater run finishes, craterbot will post a comment to the PR with a link to a report of the results.</p>
</li>
<li>
<p>Investigate the report.</p>
<p>Look through the report which contains links to build logs for any regressions or errors.</p>
</li>
<li>
<p>Close the PR.</p>
<p>Whenever you are done doing crater runs, close your PR.</p>
</li>
</ol>
<h2 id="advanced-crater-modes"><a class="header" href="#advanced-crater-modes">Advanced crater modes</a></h2>
<p>Crater only has a few built-in modes, such as running <code>cargo check</code> or <code>cargo test</code>.
You can pass extra flags with <code>+cargoflags</code>.</p>
<p>More complex tests can be accomplished by customizing Cargo to perform whatever actions you want.
Since crater essentially runs <code>cargo check</code>, you can modify the <code>check</code> command to perform whichever actions you want.
For example, to test <code>cargo fix --edition</code>, <a href="https://github.com/ehuss/cargo/commit/6901690a6f8d519efb4fabf48c1c2b94af0c3bd8">this commit</a> intercepted <code>cargo check</code> and modified it to instead:</p>
<ol>
<li>Only run on crates with the 2018 edition.</li>
<li>Run <code>cargo fix --edition</code>.</li>
<li>Modify the manifest to switch to the 2021 edition.</li>
<li>Run <code>cargo check</code> to verify.</li>
</ol>
<p>If you need to compare the before and after of a command that is not part of crater’s built-in modes, that can be more difficult.
Two possible options:</p>
<ul>
<li>Work with the infra team to add a new mode.</li>
<li>Build two custom try builds.
Each one should modify the <code>cargo check</code> command as described above.
The “start” build should perform whichever action you want with an otherwise unmodified cargo.
The “end” build should perform whichever action you want with your modified cargo.
Then, in the <code>@craterbot</code> command, specify the start and end hashes of the two try builds.</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>There are some limitations of crater to consider when running Cargo:</p>
<ul>
<li>A crater run without regressions is not a green light to move forward.
<ul>
<li>A large portion of Rust code is not tested, such as closed-source projects or things otherwise not collected by crater.</li>
<li>Many crates can’t build in crater’s environment or are otherwise broken.</li>
<li>Some crates have flaky tests.</li>
</ul>
</li>
<li>Crater runs in an isolated environment.
<ul>
<li>It only runs on Linux x86-64.</li>
<li>It does not have network access.</li>
<li>The crate source is in a read-only mount.</li>
</ul>
</li>
<li>Crater does several steps before running the test (using its own copy of the stable toolchain):
<ul>
<li>It generates a lockfile using <code>generate-lockfile</code> and includes <code>-Zno-index-update</code> to prevent index updates (which makes it run much faster).</li>
<li>All dependencies are downloaded ahead-of-time with <code>cargo fetch</code>.</li>
</ul>
</li>
<li>The built-in modes pass several flags to cargo such as <code>--frozen</code> or <code>--message-format=json</code>.
It will sometimes use <code>--all-targets</code> and sometimes not.
Check the <a href="https://github.com/rust-lang/crater/blob/master/src/runner/test.rs">crater source</a> for more details on how it works.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
